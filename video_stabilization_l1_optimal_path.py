# -*- coding: utf-8 -*-
"""video stabilization l1 optimal path.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Lcn_Omw_ErCif9MISB6SKQEccwthHFRM
"""

import cv2
import numpy as np
import sys
import cvxpy as cp

print (cv2.__version__)

!pip install opencv-contrib-python==4.3.0.38

import cv2
import numpy as np
import sys
import cvxpy as cp

def getFrameTransform(f1,f2,detector):
  f1 = cv2.cvtColor(f1, cv2.COLOR_BGR2GRAY)
  f2 = cv2.cvtColor(f2, cv2.COLOR_BGR2GRAY)

  if detector=='harris':
    prev_pts = cv2.goodFeaturesToTrack(f1, maxCorners=200, qualityLevel=0.01,minDistance=30, blockSize=3)
    curr_pts, status, err = cv2.calcOpticalFlowPyrLK(f1, f2, prev_pts, None)
    return cv2.estimateAffinePartial2D(prev_pts, curr_pts)[0]
  
	
  kp1, desc1 = detector.detectAndCompute(f1, None)
  kp2, desc2 = detector.detectAndCompute(f2, None)
	
  bf = cv2.BFMatcher()
  matches = bf.knnMatch(desc1, desc2, k=2)
	
  good = []
  for a,b in matches:
    if a.distance < 0.7*b.distance:
      good.append(a)
			
  prev_pts=[]
  curr_pts=[]
	
  for i in range(len(good)):
    prev_pts.append([kp1[good[i].queryIdx].pt[0], kp1[good[i].queryIdx].pt[1]])
    curr_pts.append([kp2[good[i].trainIdx].pt[0], kp2[good[i].trainIdx].pt[1]])

  prev_pts = np.array(prev_pts).astype(np.float32)
  curr_pts = np.array(curr_pts).astype(np.float32)
		
  return cv2.estimateAffinePartial2D(prev_pts, curr_pts)[0]
	
def getTransformation(filepath,detector):
  vid = cv2.VideoCapture(filepath)
  n_frames = int(vid.get(cv2.CAP_PROP_FRAME_COUNT))
  transforms=[[],[],[],[]]

  ret,frame=vid.read()
  prev=frame
  count=0
  while vid.isOpened():
    ret,frame=vid.read()
    if ret:
      transMat = getFrameTransform(prev, frame,detector )
      try:
        transforms[0].append(transMat[0][2])
        transforms[1].append(transMat[1][2])
        transforms[2].append(np.arctan2(transMat[1][0], transMat[0][0]))
        transforms[3].append(np.sqrt(transMat[1][0]**2 + transMat[0][0]**2))
      except:
        transforms[0].append(0)
        transforms[1].append(0)
        transforms[2].append(0)
        transforms[3].append(1)
      count+=1
      if count%5==0:
        print(count)
      prev = frame
    else:
      break
	
  vid.release()
  return transforms
    
def stabilize(transforms,threshold):
    trajectory = np.cumsum(transforms, axis=1)
    fx = cp.Variable(len(trajectory[0]))
    fy = cp.Variable(len(trajectory[1]))
    fth = cp.Variable(len(trajectory[2]))
    fs = cp.Variable(len(trajectory[3]))

    lbd1 = 10000
    lbd2 = 1000
    lbd3 = 100000
    DispThresh = int(threshold)
    constraints = [cp.abs(fx - trajectory[0]) <= DispThresh,
 			   cp.abs(fy - trajectory[1]) <= DispThresh,
 			   cp.abs(fth - trajectory[2]) <= 0.05,
 			   cp.abs(fs - trajectory[3]) <= 0.01]
    
    obj = 0																																																																																								
    for i in range(len(trajectory[0])):
        obj += ( (trajectory[0][i]-fx[i])**2 + (trajectory[1][i]-fy[i])**2 + (trajectory[2][i]-fth[i])**2 + (trajectory[3][i]-fs[i])**2 )

    for i in range(len(trajectory[0])-1):
        obj += lbd1*(cp.abs(fx[i+1]-fx[i]) + cp.abs(fy[i+1]-fy[i]) + cp.abs(fth[i+1]-fth[i]) + cp.abs(fs[i+1]-fs[i]))

    for i in range(len(trajectory[0])-2):
        obj += lbd2*(cp.abs(fx[i+2]-2*fx[i+1]+fx[i]) + cp.abs(fy[i+2]-2*fy[i+1]+fy[i]) + cp.abs(fth[i+2]-2*fth[i+1]+fth[i]) + cp.abs(fs[i+2]-2*fs[i+1]+fs[i]))

    for i in range(len(trajectory[0])-3):
        obj += lbd3*(cp.abs(fx[i+3]-3*fx[i+2] + 3*fx[i+1]-fx[i]) + cp.abs(fy[i+3]-3*fy[i+2]+3*fy[i+1]-fy[i]) + cp.abs(fth[i+3]-3*fth[i+2]+3*fth[i+1]-fth[i]) + cp.abs(fs[i+3]-3*fs[i+2]+3*fs[i+1]-fs[i]))
    
    prob = cp.Problem(cp.Minimize(obj), constraints)
    print("Started Solving the optimization using ECOS")
    prob.solve(solver=cp.ECOS)#ECOS, OSQP, and SCS
    print("Optimization solved")
    
    smoothTrajectory = np.array([fx.value, fy.value, fth.value, fs.value])

    # Box trajectory
    difference = trajectory - smoothTrajectory

    # Frame transform
    smoothTransforms = transforms - difference

    return smoothTransforms


def makeVid(filepath,stabilized,threshold):
    vid = cv2.VideoCapture(filepath)
    width = int(vid.get(cv2.CAP_PROP_FRAME_WIDTH))
    height = int(vid.get(cv2.CAP_PROP_FRAME_HEIGHT))
    fps = int(vid.get(cv2.CAP_PROP_FPS))
    n_frames = int(vid.get(cv2.CAP_PROP_FRAME_COUNT))
    out = cv2.VideoWriter('video_stabilized.avi', cv2.VideoWriter_fourcc(*'XVID'), fps, (width-2*threshold, height-2*threshold))
    
    m = np.zeros([2, 3])
    for i in range(n_frames-1):
      ret, frame = vid.read()
      if ret == True:
        m[0][0] = (stabilized[3][i])*np.cos(stabilized[2][i])
        m[0][1] = -(stabilized[3][i])*np.sin(stabilized[2][i])
        m[1][0] = (stabilized[3][i])*np.sin(stabilized[2][i])
        m[1][1] = (stabilized[3][i])*np.cos(stabilized[2][i])
        m[0][2] = stabilized[0][i]
        m[1][2] = stabilized[1][i]
        stable = cv2.warpAffine(frame, m, (width, height))
        boxPart = stable[threshold:height-threshold, threshold:width-threshold,:]
        out.write(boxPart)
      else:
        break
    
    vid.release()
    out.release()


def StabVid(filepath,threshold,detector):
    transformation=getTransformation(filepath,detector)
    stabilized=stabilize(transformation,threshold)
    makeVid(filepath,stabilized,threshold)

    cv2.destroyAllWindows()

sift = cv2.xfeatures2d.SIFT_create(200)
orb = cv2.ORB_create(200)#much faster
#harris fastest
StabVid('vid1.mp4',0,'harris')